import { r as resolveTLSOptions, a as resolvePort, f as fmtURL } from '../shared/srvx.lC_d9z2b.mjs';
import { w as wrapFetch } from '../shared/srvx.DhN4g5wJ.mjs';
import 'node:fs';

const Response = globalThis.Response;
function serve(options) {
  return new DenoServer(options);
}
class DenoServer {
  constructor(options) {
    this.runtime = "deno";
    this.deno = {};
    this.options = options;
    const fetchHandler = wrapFetch(this, this.options.fetch);
    this.fetch = (request, info) => {
      Object.defineProperties(request, {
        deno: { value: { info, server: this.deno?.server }, enumerable: true },
        remoteAddress: {
          get: () => info?.remoteAddr?.hostname,
          enumerable: true
        }
      });
      return fetchHandler(request);
    };
    const tls = resolveTLSOptions(this.options);
    this.serveOptions = {
      port: resolvePort(this.options.port, globalThis.Deno?.env.get("PORT")),
      hostname: this.options.hostname,
      reusePort: this.options.reusePort,
      ...tls ? { key: tls.key, cert: tls.cert, passphrase: tls.passphrase } : {},
      ...this.options.deno
    };
    if (!options.manual) {
      this.serve();
    }
  }
  #listeningPromise;
  #listeningInfo;
  serve() {
    if (this.deno?.server) {
      return Promise.resolve(this.#listeningPromise).then(() => this);
    }
    const onListenPromise = Promise.withResolvers();
    this.#listeningPromise = onListenPromise.promise;
    this.deno.server = Deno.serve(
      {
        ...this.serveOptions,
        onListen: (info) => {
          this.#listeningInfo = info;
          if (this.options.deno?.onListen) {
            this.options.deno.onListen(info);
          }
          onListenPromise.resolve();
        }
      },
      this.fetch
    );
    return Promise.resolve(this.#listeningPromise).then(() => this);
  }
  get url() {
    return this.#listeningInfo ? fmtURL(
      this.#listeningInfo.hostname,
      this.#listeningInfo.port,
      !!this.serveOptions.cert
    ) : void 0;
  }
  ready() {
    return Promise.resolve(this.#listeningPromise).then(() => this);
  }
  close() {
    return Promise.resolve(this.deno?.server?.shutdown());
  }
}

export { Response, serve };
