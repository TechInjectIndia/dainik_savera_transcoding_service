import NodeHttp from 'node:http';
import NodeHttps from 'node:https';
import { splitSetCookieString } from 'cookie-es';
import { r as resolveTLSOptions, a as resolvePort, f as fmtURL } from '../shared/srvx.lC_d9z2b.mjs';
import { w as wrapFetch } from '../shared/srvx.DhN4g5wJ.mjs';
import 'node:fs';

async function sendNodeResponse(nodeRes, webRes) {
  if (!webRes) {
    nodeRes.statusCode = 500;
    return endNodeResponse(nodeRes);
  }
  if (webRes.nodeResponse) {
    const res = webRes.nodeResponse();
    if (!nodeRes.headersSent) {
      nodeRes.writeHead(res.status, res.statusText, res.headers.flat());
    }
    if (res.body) {
      if (res.body instanceof ReadableStream) {
        return streamBody(res.body, nodeRes);
      } else if (typeof res.body?.pipe === "function") {
        res.body.pipe(nodeRes);
        return new Promise((resolve) => nodeRes.on("close", resolve));
      }
      nodeRes.write(res.body);
    }
    return endNodeResponse(nodeRes);
  }
  const headerEntries = [];
  for (const [key, value] of webRes.headers) {
    if (key === "set-cookie") {
      for (const setCookie of splitSetCookieString(value)) {
        headerEntries.push(["set-cookie", setCookie]);
      }
    } else {
      headerEntries.push([key, value]);
    }
  }
  if (!nodeRes.headersSent) {
    nodeRes.writeHead(
      webRes.status || 200,
      webRes.statusText,
      headerEntries.flat()
    );
  }
  return webRes.body ? streamBody(webRes.body, nodeRes) : endNodeResponse(nodeRes);
}
function endNodeResponse(nodeRes) {
  return new Promise((resolve) => nodeRes.end(resolve));
}
function streamBody(stream, nodeRes) {
  if (nodeRes.destroyed) {
    stream.cancel();
    return;
  }
  const reader = stream.getReader();
  function streamCancel(error) {
    reader.cancel(error).catch(() => {
    });
    if (error) {
      nodeRes.destroy(error);
    }
  }
  function streamHandle({
    done,
    value
  }) {
    try {
      if (done) {
        nodeRes.end();
      } else if (nodeRes.write(value)) {
        reader.read().then(streamHandle, streamCancel);
      } else {
        nodeRes.once(
          "drain",
          () => reader.read().then(streamHandle, streamCancel)
        );
      }
    } catch (error) {
      streamCancel(error instanceof Error ? error : void 0);
    }
  }
  nodeRes.on("close", streamCancel);
  nodeRes.on("error", streamCancel);
  reader.read().then(streamHandle, streamCancel);
  return reader.closed.finally(() => {
    nodeRes.off("close", streamCancel);
    nodeRes.off("error", streamCancel);
  });
}

const kNodeInspect = /* @__PURE__ */ Symbol.for(
  "nodejs.util.inspect.custom"
);

const NodeRequestHeaders = /* @__PURE__ */ (() => {
  const _Headers = class Headers {
    constructor(nodeCtx) {
      this.node = nodeCtx;
    }
    append(name, value) {
      name = name.toLowerCase();
      const _headers = this.node.req.headers;
      const _current = _headers[name];
      if (_current) {
        if (Array.isArray(_current)) {
          _current.push(value);
        } else {
          _headers[name] = [_current, value];
        }
      } else {
        _headers[name] = value;
      }
    }
    delete(name) {
      name = name.toLowerCase();
      this.node.req.headers[name] = void 0;
    }
    get(name) {
      name = name.toLowerCase();
      const rawValue = this.node.req.headers[name];
      if (rawValue === void 0) {
        return null;
      }
      return _normalizeValue(this.node.req.headers[name]);
    }
    getSetCookie() {
      const setCookie = this.node.req.headers["set-cookie"];
      if (!setCookie || setCookie.length === 0) {
        return [];
      }
      return splitSetCookieString(setCookie);
    }
    has(name) {
      name = name.toLowerCase();
      return !!this.node.req.headers[name];
    }
    set(name, value) {
      name = name.toLowerCase();
      this.node.req.headers[name] = value;
    }
    get count() {
      throw new Error("Method not implemented.");
    }
    getAll(_name) {
      throw new Error("Method not implemented.");
    }
    toJSON() {
      const _headers = this.node.req.headers;
      const result = {};
      for (const key in _headers) {
        if (_headers[key]) {
          result[key] = _normalizeValue(_headers[key]);
        }
      }
      return result;
    }
    forEach(cb, thisArg) {
      const _headers = this.node.req.headers;
      for (const key in _headers) {
        if (_headers[key]) {
          cb.call(
            thisArg,
            _normalizeValue(_headers[key]),
            key,
            this
          );
        }
      }
    }
    *entries() {
      const _headers = this.node.req.headers;
      for (const key in _headers) {
        yield [key, _normalizeValue(_headers[key])];
      }
    }
    *keys() {
      const keys = Object.keys(this.node.req.headers);
      for (const key of keys) {
        yield key;
      }
    }
    *values() {
      const values = Object.values(this.node.req.headers);
      for (const value of values) {
        yield _normalizeValue(value);
      }
    }
    [Symbol.iterator]() {
      return this.entries()[Symbol.iterator]();
    }
    get [Symbol.toStringTag]() {
      return "Headers";
    }
    [kNodeInspect]() {
      return Object.fromEntries(this.entries());
    }
  };
  Object.setPrototypeOf(_Headers.prototype, globalThis.Headers.prototype);
  return _Headers;
})();
const NodeResponseHeaders = /* @__PURE__ */ (() => {
  const _Headers = class Headers {
    constructor(nodeCtx) {
      this.node = nodeCtx;
    }
    append(name, value) {
      this.node.res.appendHeader(name, value);
    }
    delete(name) {
      this.node.res.removeHeader(name);
    }
    get(name) {
      const rawValue = this.node.res.getHeader(name);
      if (rawValue === void 0) {
        return null;
      }
      return _normalizeValue(rawValue);
    }
    getSetCookie() {
      const setCookie = _normalizeValue(this.node.res.getHeader("set-cookie"));
      if (!setCookie) {
        return [];
      }
      return splitSetCookieString(setCookie);
    }
    has(name) {
      return this.node.res.hasHeader(name);
    }
    set(name, value) {
      this.node.res.setHeader(name, value);
    }
    get count() {
      throw new Error("Method not implemented.");
    }
    getAll(_name) {
      throw new Error("Method not implemented.");
    }
    toJSON() {
      const _headers = this.node.res.getHeaders();
      const result = {};
      for (const key in _headers) {
        if (_headers[key]) {
          result[key] = _normalizeValue(_headers[key]);
        }
      }
      return result;
    }
    forEach(cb, thisArg) {
      const _headers = this.node.res.getHeaders();
      for (const key in _headers) {
        if (_headers[key]) {
          cb.call(
            thisArg,
            _normalizeValue(_headers[key]),
            key,
            this
          );
        }
      }
    }
    *entries() {
      const _headers = this.node.res.getHeaders();
      for (const key in _headers) {
        yield [key, _normalizeValue(_headers[key])];
      }
    }
    *keys() {
      const keys = this.node.res.getHeaderNames();
      for (const key of keys) {
        yield key;
      }
    }
    *values() {
      const values = Object.values(this.node.res.getHeaders());
      for (const value of values) {
        yield _normalizeValue(value);
      }
    }
    [Symbol.iterator]() {
      return this.entries()[Symbol.iterator]();
    }
    get [Symbol.toStringTag]() {
      return "Headers";
    }
    [kNodeInspect]() {
      return Object.fromEntries(this.entries());
    }
  };
  Object.setPrototypeOf(_Headers.prototype, globalThis.Headers.prototype);
  return _Headers;
})();
function _normalizeValue(value) {
  if (Array.isArray(value)) {
    return value.join(", ");
  }
  return typeof value === "string" ? value : String(value ?? "");
}

const NodeRequestURL = /* @__PURE__ */ (() => {
  const _URL = class URL {
    constructor(nodeCtx) {
      this._hash = "";
      this._username = "";
      this._password = "";
      this.node = nodeCtx;
    }
    get hash() {
      return this._hash;
    }
    set hash(value) {
      this._hash = value;
    }
    get username() {
      return this._username;
    }
    set username(value) {
      this._username = value;
    }
    get password() {
      return this._password;
    }
    set password(value) {
      this._password = value;
    }
    // host
    get host() {
      return this.node.req.headers.host || "";
    }
    set host(value) {
      this._hostname = void 0;
      this._port = void 0;
      this.node.req.headers.host = value;
    }
    // hostname
    get hostname() {
      if (this._hostname === void 0) {
        const [hostname, port] = parseHost(this.node.req.headers.host);
        if (this._port === void 0 && port) {
          this._port = String(Number.parseInt(port) || "");
        }
        this._hostname = hostname || "localhost";
      }
      return this._hostname;
    }
    set hostname(value) {
      this._hostname = value;
    }
    // port
    get port() {
      if (this._port === void 0) {
        const [hostname, port] = parseHost(this.node.req.headers.host);
        if (this._hostname === void 0 && hostname) {
          this._hostname = hostname;
        }
        this._port = port || String(this.node.req.socket?.localPort || "");
      }
      return this._port;
    }
    set port(value) {
      this._port = String(Number.parseInt(value) || "");
    }
    // pathname
    get pathname() {
      if (this._pathname === void 0) {
        const [pathname, search] = parsePath(this.node.req.url || "/");
        this._pathname = pathname;
        if (this._search === void 0) {
          this._search = search;
        }
      }
      return this._pathname;
    }
    set pathname(value) {
      if (value[0] !== "/") {
        value = "/" + value;
      }
      if (value === this._pathname) {
        return;
      }
      this._pathname = value;
      this.node.req.url = value + this.search;
    }
    // search
    get search() {
      if (this._search === void 0) {
        const [pathname, search] = parsePath(this.node.req.url || "/");
        this._search = search;
        if (this._pathname === void 0) {
          this._pathname = pathname;
        }
      }
      return this._search;
    }
    set search(value) {
      if (value === "?") {
        value = "";
      } else if (value && value[0] !== "?") {
        value = "?" + value;
      }
      if (value === this._search) {
        return;
      }
      this._search = value;
      this._searchParams = void 0;
      this.node.req.url = this.pathname + value;
    }
    // searchParams
    get searchParams() {
      if (!this._searchParams) {
        this._searchParams = new URLSearchParams(this.search);
      }
      return this._searchParams;
    }
    set searchParams(value) {
      this._searchParams = value;
      this._search = value.toString();
    }
    // protocol
    get protocol() {
      if (!this._protocol) {
        this._protocol = this.node.req.socket?.encrypted || this.node.req.headers["x-forwarded-proto"] === "https" ? "https:" : "http:";
      }
      return this._protocol;
    }
    set protocol(value) {
      this._protocol = value;
    }
    // origin
    get origin() {
      return `${this.protocol}//${this.host}`;
    }
    set origin(_value) {
    }
    // href
    get href() {
      return `${this.protocol}//${this.host}${this.pathname}${this.search}`;
    }
    set href(value) {
      const _url = new globalThis.URL(value);
      this._protocol = _url.protocol;
      this.username = _url.username;
      this.password = _url.password;
      this._hostname = _url.hostname;
      this._port = _url.port;
      this.pathname = _url.pathname;
      this.search = _url.search;
      this.hash = _url.hash;
    }
    toString() {
      return this.href;
    }
    toJSON() {
      return this.href;
    }
    get [Symbol.toStringTag]() {
      return "URL";
    }
    [kNodeInspect]() {
      return this.href;
    }
  };
  Object.setPrototypeOf(_URL.prototype, globalThis.URL.prototype);
  return _URL;
})();
function parsePath(input) {
  const url = (input || "/").replace(/\\/g, "/");
  const qIndex = url.indexOf("?");
  if (qIndex === -1) {
    return [url, ""];
  }
  return [url.slice(0, qIndex), url.slice(qIndex)];
}
function parseHost(host) {
  const s = (host || "").split(":");
  return [s[0], String(Number.parseInt(s[1]) || "")];
}

const NodeRequest = /* @__PURE__ */ (() => {
  const _Request = class Request {
    #url;
    #headers;
    #bodyUsed = false;
    #abortSignal;
    #hasBody;
    #bodyBytes;
    #blobBody;
    #formDataBody;
    #jsonBody;
    #textBody;
    #bodyStream;
    constructor(nodeCtx) {
      this.node = nodeCtx;
    }
    get headers() {
      if (!this.#headers) {
        this.#headers = new NodeRequestHeaders(this.node);
      }
      return this.#headers;
    }
    get remoteAddress() {
      return this.node.req.socket?.remoteAddress;
    }
    clone() {
      return new _Request({ ...this.node });
    }
    get _url() {
      if (!this.#url) {
        this.#url = new NodeRequestURL(this.node);
      }
      return this.#url;
    }
    get url() {
      return this._url.href;
    }
    get method() {
      return this.node.req.method || "GET";
    }
    get signal() {
      if (!this.#abortSignal) {
        this.#abortSignal = new AbortController();
      }
      return this.#abortSignal.signal;
    }
    get bodyUsed() {
      return this.#bodyUsed;
    }
    get _hasBody() {
      if (this.#hasBody !== void 0) {
        return this.#hasBody;
      }
      const method = this.node.req.method?.toUpperCase();
      if (!method || !(method === "PATCH" || method === "POST" || method === "PUT" || method === "DELETE")) {
        this.#hasBody = false;
        return false;
      }
      if (!Number.parseInt(this.node.req.headers["content-length"] || "")) {
        const isChunked = (this.node.req.headers["transfer-encoding"] || "").split(",").map((e) => e.trim()).filter(Boolean).includes("chunked");
        if (!isChunked) {
          this.#hasBody = false;
          return false;
        }
      }
      this.#hasBody = true;
      return true;
    }
    get body() {
      if (!this._hasBody) {
        return null;
      }
      if (!this.#bodyStream) {
        this.#bodyUsed = true;
        this.#bodyStream = new ReadableStream({
          start: (controller) => {
            this.node.req.on("data", (chunk) => {
              controller.enqueue(chunk);
            }).once("error", (error) => {
              controller.error(error);
              this.#abortSignal?.abort();
            }).once("close", () => {
              this.#abortSignal?.abort();
            }).once("end", () => {
              controller.close();
            });
          }
        });
      }
      return this.#bodyStream;
    }
    bytes() {
      if (!this.#bodyBytes) {
        const _bodyStream = this.body;
        this.#bodyBytes = _bodyStream ? _readStream(_bodyStream) : Promise.resolve(new Uint8Array());
      }
      return this.#bodyBytes;
    }
    arrayBuffer() {
      return this.bytes().then((buff) => {
        return buff.buffer.slice(
          buff.byteOffset,
          buff.byteOffset + buff.byteLength
        );
      });
    }
    blob() {
      if (!this.#blobBody) {
        this.#blobBody = this.bytes().then((bytes) => {
          return new Blob([bytes], {
            type: this.node.req.headers["content-type"]
          });
        });
      }
      return this.#blobBody;
    }
    formData() {
      if (!this.#formDataBody) {
        this.#formDataBody = new Response(this.body, {
          headers: this.headers
        }).formData();
      }
      return this.#formDataBody;
    }
    text() {
      if (!this.#textBody) {
        this.#textBody = this.bytes().then((bytes) => {
          return new TextDecoder().decode(bytes);
        });
      }
      return this.#textBody;
    }
    json() {
      if (!this.#jsonBody) {
        this.#jsonBody = this.text().then((txt) => {
          return JSON.parse(txt);
        });
      }
      return this.#jsonBody;
    }
    get [Symbol.toStringTag]() {
      return "Request";
    }
    [kNodeInspect]() {
      return {
        method: this.method,
        url: this.url,
        headers: this.headers
      };
    }
  };
  Object.setPrototypeOf(_Request.prototype, globalThis.Request.prototype);
  return _Request;
})();
async function _readStream(stream) {
  const chunks = [];
  await stream.pipeTo(
    new WritableStream({
      write(chunk) {
        chunks.push(chunk);
      }
    })
  );
  return Buffer.concat(chunks);
}

const NodeResponse = /* @__PURE__ */ (() => {
  const CONTENT_TYPE = "content-type";
  const JSON_TYPE = "application/json";
  const JSON_HEADER = [[CONTENT_TYPE, JSON_TYPE]];
  const _Response = class Response {
    #body;
    #init;
    constructor(body, init) {
      this.#body = body;
      this.#init = init;
    }
    static json(data, init) {
      if (init?.headers) {
        if (!init.headers[CONTENT_TYPE]) {
          const initHeaders = new Headers(init.headers);
          if (!initHeaders.has(CONTENT_TYPE)) {
            initHeaders.set(CONTENT_TYPE, JSON_TYPE);
          }
          init = { ...init, headers: initHeaders };
        }
      } else {
        init = init ? { ...init } : {};
        init.headers = JSON_HEADER;
      }
      return new _Response(JSON.stringify(data), init);
    }
    static error() {
      return globalThis.Response.error();
    }
    static redirect(url, status) {
      return globalThis.Response.redirect(url, status);
    }
    /**
     * Prepare Node.js response object
     */
    nodeResponse() {
      const status = this.#init?.status ?? 200;
      const statusText = this.#init?.statusText ?? "";
      const headers = [];
      const headersInit = this.#init?.headers;
      if (headersInit) {
        const headerEntries = headersInit.entries ? headersInit.entries() : Object.entries(headersInit);
        for (const [key, value] of headerEntries) {
          if (key === "set-cookie") {
            for (const setCookie of splitSetCookieString(value)) {
              headers.push(["set-cookie", setCookie]);
            }
          } else {
            headers.push([key, value]);
          }
        }
      }
      const bodyInit = this.#body;
      let body;
      if (bodyInit) {
        if (typeof bodyInit === "string") {
          body = bodyInit;
        } else if (bodyInit instanceof ReadableStream) {
          body = bodyInit;
        } else if (bodyInit instanceof ArrayBuffer) {
          body = Buffer.from(bodyInit);
        } else if (bodyInit instanceof Uint8Array) {
          body = Buffer.from(bodyInit);
        } else if (bodyInit instanceof DataView) {
          body = Buffer.from(bodyInit.buffer);
        } else if (bodyInit instanceof Blob) {
          body = bodyInit.stream();
          if (bodyInit.type) {
            headers.push(["content-type", bodyInit.type]);
          }
        } else if (typeof bodyInit.pipe === "function") {
          body = bodyInit;
        } else {
          const res = new globalThis.Response(bodyInit);
          body = res.body;
          for (const [key, value] of res.headers) {
            headers.push([key, value]);
          }
        }
      }
      this.#body = void 0;
      this.#init = void 0;
      return {
        status,
        statusText,
        headers,
        body
      };
    }
    // ... the rest is for interface compatibility only and usually not to be used ...
    /** Lazy initialized response instance */
    #responseObj;
    /** Lazy initialized headers instance */
    #headersObj;
    clone() {
      if (this.#responseObj) {
        return this.#responseObj.clone();
      }
      return new globalThis.Response(this.#body, this.#init);
    }
    get #response() {
      if (!this.#responseObj) {
        this.#responseObj = new globalThis.Response(this.#body, this.#init);
        this.#body = void 0;
        this.#init = void 0;
        this.#headersObj = void 0;
      }
      return this.#responseObj;
    }
    get headers() {
      if (this.#responseObj) {
        return this.#responseObj.headers;
      }
      if (!this.#headersObj) {
        this.#headersObj = new Headers(this.#init?.headers);
      }
      return this.#headersObj;
    }
    get ok() {
      if (this.#responseObj) {
        return this.#responseObj.ok;
      }
      const status = this.#init?.status ?? 200;
      return status >= 200 && status < 300;
    }
    get redirected() {
      if (this.#responseObj) {
        return this.#responseObj.redirected;
      }
      return false;
    }
    get status() {
      if (this.#responseObj) {
        return this.#responseObj.status;
      }
      return this.#init?.status ?? 200;
    }
    get statusText() {
      if (this.#responseObj) {
        return this.#responseObj.statusText;
      }
      return this.#init?.statusText ?? "";
    }
    get type() {
      if (this.#responseObj) {
        return this.#responseObj.type;
      }
      return "default";
    }
    get url() {
      if (this.#responseObj) {
        return this.#responseObj.url;
      }
      return "";
    }
    // --- body ---
    #fastBody(as) {
      const bodyInit = this.#body;
      if (bodyInit === null || bodyInit === void 0) {
        return null;
      }
      if (bodyInit instanceof as) {
        return bodyInit;
      }
      return false;
    }
    get body() {
      if (this.#responseObj) {
        return this.#responseObj.body;
      }
      const fastBody = this.#fastBody(ReadableStream);
      if (fastBody !== false) {
        return fastBody;
      }
      return this.#response.body;
    }
    get bodyUsed() {
      if (this.#responseObj) {
        return this.#responseObj.bodyUsed;
      }
      return false;
    }
    arrayBuffer() {
      if (this.#responseObj) {
        return this.#responseObj.arrayBuffer();
      }
      const fastBody = this.#fastBody(ArrayBuffer);
      if (fastBody !== false) {
        return Promise.resolve(fastBody || new ArrayBuffer(0));
      }
      return this.#response.arrayBuffer();
    }
    blob() {
      if (this.#responseObj) {
        return this.#responseObj.blob();
      }
      const fastBody = this.#fastBody(Blob);
      if (fastBody !== false) {
        return Promise.resolve(fastBody || new Blob());
      }
      return this.#response.blob();
    }
    bytes() {
      if (this.#responseObj) {
        return this.#responseObj.bytes();
      }
      const fastBody = this.#fastBody(Uint8Array);
      if (fastBody !== false) {
        return Promise.resolve(fastBody || new Uint8Array());
      }
      return this.#response.bytes();
    }
    formData() {
      if (this.#responseObj) {
        return this.#responseObj.formData();
      }
      const fastBody = this.#fastBody(FormData);
      if (fastBody !== false) {
        return Promise.resolve(fastBody || new FormData());
      }
      return this.#response.formData();
    }
    text() {
      if (this.#responseObj) {
        return this.#responseObj.text();
      }
      const bodyInit = this.#body;
      if (bodyInit === null || bodyInit === void 0) {
        return Promise.resolve("");
      }
      if (typeof bodyInit === "string") {
        return Promise.resolve(bodyInit);
      }
      return this.#response.text();
    }
    json() {
      if (this.#responseObj) {
        return this.#responseObj.json();
      }
      return this.text().then((text) => JSON.parse(text));
    }
  };
  Object.setPrototypeOf(_Response.prototype, globalThis.Response.prototype);
  return _Response;
})();

function serve(options) {
  return new NodeServer(options);
}
function toNodeHandler(fetchHandler) {
  return (nodeReq, nodeRes) => {
    const request = new NodeRequest({ req: nodeReq, res: nodeRes });
    const res = fetchHandler(request);
    return res instanceof Promise ? res.then((resolvedRes) => sendNodeResponse(nodeRes, resolvedRes)) : sendNodeResponse(nodeRes, res);
  };
}
class NodeServer {
  constructor(options) {
    this.runtime = "node";
    this.options = options;
    const fetchHandler = wrapFetch(this, this.options.fetch);
    this.fetch = fetchHandler;
    const handler = (nodeReq, nodeRes) => {
      const request = new NodeRequest({ req: nodeReq, res: nodeRes });
      const res = fetchHandler(request);
      return res instanceof Promise ? res.then((resolvedRes) => sendNodeResponse(nodeRes, resolvedRes)) : sendNodeResponse(nodeRes, res);
    };
    const tls = resolveTLSOptions(this.options);
    this.serveOptions = {
      port: resolvePort(this.options.port, globalThis.process?.env.PORT),
      host: this.options.hostname,
      exclusive: !this.options.reusePort,
      ...tls ? { cert: tls.cert, key: tls.key, passphrase: tls.passphrase } : {},
      ...this.options.node
    };
    const server = this.serveOptions.cert ? NodeHttps.createServer(
      this.serveOptions,
      handler
    ) : NodeHttp.createServer(this.serveOptions, handler);
    this.node = { server, handler };
    if (!options.manual) {
      this.serve();
    }
  }
  #listeningPromise;
  serve() {
    if (this.#listeningPromise) {
      return Promise.resolve(this.#listeningPromise).then(() => this);
    }
    this.#listeningPromise = new Promise((resolve) => {
      this.node.server.listen(this.serveOptions, () => resolve());
    });
  }
  get url() {
    const addr = this.node?.server?.address();
    if (!addr) {
      return;
    }
    return typeof addr === "string" ? addr : fmtURL(
      addr.address,
      addr.port,
      this.node.server instanceof NodeHttps.Server
    );
  }
  ready() {
    return Promise.resolve(this.#listeningPromise).then(() => this);
  }
  close(closeAll) {
    return new Promise((resolve, reject) => {
      if (closeAll) {
        this.node?.server?.closeAllConnections?.();
      }
      this.node?.server?.close(
        (error) => error ? reject(error) : resolve()
      );
    });
  }
}

export { NodeRequest, NodeRequestHeaders, NodeResponse, NodeResponseHeaders, NodeRequest as Request, NodeResponse as Response, serve, toNodeHandler };
