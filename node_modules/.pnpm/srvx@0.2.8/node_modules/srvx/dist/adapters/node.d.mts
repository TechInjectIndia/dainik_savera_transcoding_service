import { ServerRequest, ServerOptions, Server, FetchHandler, NodeHttpHandler } from '../types.mjs';
import NodeHttp__default from 'node:http';
import { Readable } from 'node:stream';
import 'node:https';
import 'node:net';
import 'bun';
import '@cloudflare/workers-types';

type NodeResponse = InstanceType<typeof NodeResponse>;
/**
 * Fast Response for Node.js runtime
 *
 * It is faster because in most cases it doesn't create a full Response instance.
 */
declare const NodeResponse: {
    new (body?: BodyInit | null, init?: ResponseInit): {
        "__#4363@#body"?: BodyInit | null;
        "__#4363@#init"?: ResponseInit;
        /**
         * Prepare Node.js response object
         */
        nodeResponse(): {
            status: number;
            statusText: string;
            headers: NodeHttp__default.OutgoingHttpHeader[];
            body: string | Buffer<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | ReadableStream<Uint8Array<ArrayBufferLike>> | Readable | DataView<ArrayBufferLike> | null | undefined;
        };
        /** Lazy initialized response instance */
        "__#4363@#responseObj"?: globalThis.Response;
        /** Lazy initialized headers instance */
        "__#4363@#headersObj"?: Headers;
        clone(): globalThis.Response;
        readonly "__#4363@#response": globalThis.Response;
        readonly headers: Headers;
        readonly ok: boolean;
        readonly redirected: boolean;
        readonly status: number;
        readonly statusText: string;
        readonly type: ResponseType;
        readonly url: string;
        "__#4363@#fastBody"<T extends object>(as: new (...args: any[]) => T): T | null | false;
        readonly body: ReadableStream<Uint8Array> | null;
        readonly bodyUsed: boolean;
        arrayBuffer(): Promise<ArrayBuffer>;
        blob(): Promise<Blob>;
        bytes(): Promise<Uint8Array>;
        formData(): Promise<FormData>;
        text(): Promise<string>;
        json(): Promise<any>;
    };
    json(data: any, init?: ResponseInit): globalThis.Response;
    error(): globalThis.Response;
    redirect(url: string | URL, status?: number): globalThis.Response;
};

declare const NodeRequest: {
    new (nodeCtx: {
        req: NodeHttp__default.IncomingMessage;
        res: NodeHttp__default.ServerResponse;
    }): ServerRequest;
};

declare const kNodeInspect: unique symbol;

declare const NodeRequestHeaders: {
    new (nodeCtx: {
        req: NodeHttp__default.IncomingMessage;
        res?: NodeHttp__default.ServerResponse;
    }): {
        node: {
            req: NodeHttp__default.IncomingMessage;
            res?: NodeHttp__default.ServerResponse;
        };
        append(name: string, value: string): void;
        delete(name: string): void;
        get(name: string): string | null;
        getSetCookie(): string[];
        has(name: string): boolean;
        set(name: string, value: string): void;
        readonly count: number;
        getAll(_name: "set-cookie" | "Set-Cookie"): string[];
        toJSON(): Record<string, string>;
        forEach(cb: (value: string, key: string, parent: /*elided*/ any) => void, thisArg?: any): void;
        entries(): HeadersIterator<[string, string]>;
        keys(): HeadersIterator<string>;
        values(): HeadersIterator<string>;
        [Symbol.iterator](): HeadersIterator<[string, string]>;
        readonly [Symbol.toStringTag]: string;
        [kNodeInspect](): {
            [k: string]: string;
        };
    };
};
declare const NodeResponseHeaders: {
    new (nodeCtx: {
        req?: NodeHttp__default.IncomingMessage;
        res: NodeHttp__default.ServerResponse;
    }): {
        node: {
            req?: NodeHttp__default.IncomingMessage;
            res: NodeHttp__default.ServerResponse;
        };
        append(name: string, value: string): void;
        delete(name: string): void;
        get(name: string): string | null;
        getSetCookie(): string[];
        has(name: string): boolean;
        set(name: string, value: string): void;
        readonly count: number;
        getAll(_name: "set-cookie" | "Set-Cookie"): string[];
        toJSON(): Record<string, string>;
        forEach(cb: (value: string, key: string, parent: /*elided*/ any) => void, thisArg?: any): void;
        entries(): HeadersIterator<[string, string]>;
        keys(): HeadersIterator<string>;
        values(): HeadersIterator<string>;
        [Symbol.iterator](): HeadersIterator<[string, string]>;
        readonly [Symbol.toStringTag]: string;
        [kNodeInspect](): {
            [k: string]: string;
        };
    };
};

declare function serve(options: ServerOptions): Server;
declare function toNodeHandler(fetchHandler: FetchHandler): NodeHttpHandler;

export { NodeRequest, NodeRequestHeaders, NodeResponse, NodeResponseHeaders, NodeRequest as Request, NodeResponse as Response, serve, toNodeHandler };
